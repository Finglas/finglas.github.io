<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Shaun Finglas - 2019</title><link href="https://blog.shaunfinglas.co.uk/" rel="alternate"></link><link href="https://blog.shaunfinglas.co.uk/feeds/2019.atom.xml" rel="self"></link><id>https://blog.shaunfinglas.co.uk/</id><updated>2019-12-22T00:00:00+01:00</updated><entry><title>Refactoring CI Build Pipelines</title><link href="https://blog.shaunfinglas.co.uk/2019/22/refactoring-ci-build-pipelines.html" rel="alternate"></link><published>2019-12-22T00:00:00+01:00</published><updated>2019-12-22T00:00:00+01:00</updated><author><name>Shaun Finglas</name></author><id>tag:blog.shaunfinglas.co.uk,2019-12-22:/2019/22/refactoring-ci-build-pipelines.html</id><summary type="html">&lt;h3&gt;Problem with CI Tooling&lt;/h3&gt;
&lt;p&gt;CI tools such as Team City are great. They provide a nice front end that can be used as control for all your builds. The likes of triggers, test results and build history are some of the stand out features.&lt;/p&gt;
&lt;p&gt;In addition to these features there …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Problem with CI Tooling&lt;/h3&gt;
&lt;p&gt;CI tools such as Team City are great. They provide a nice front end that can be used as control for all your builds. The likes of triggers, test results and build history are some of the stand out features.&lt;/p&gt;
&lt;p&gt;In addition to these features there is a whole host of other functionality that is built in. Just try and add a new step, the dropdown will contain many different tools that can easily be configured. &lt;/p&gt;
&lt;p&gt;My problem here is that configuring your build pipeline via these tools is asking for trouble. In fact I would go as far as to say that the use of these tools to control your build is an extremely poor practice that should be avoided.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;It ties you to that particular tool. While it is not hugely common to switch CI tools I have repeated this task several times over several companies. It does happen.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Feedback is slowed down. If you wish to make a change you either need to commit or modify the pipeline. This either works or if it doesn't breaks the build for everyone else. If the key to success in DevOps is fast feedback, this style of work is not compatible. The use of a test CI pipeline is an overhead.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Depending on the type of company you work for, you may or may not have full control over the CI environment. This further limits speed of feedback and experimentation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Source control is an issue with such tools. While it is possible to see and audit changes this is separate to your standard source control. If build &lt;code&gt;1.2.3&lt;/code&gt; is produced it should contain all changes for that version, including build steps or deployment changes. I don't want these stored in an external tool or proprietary format.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;To counter the issues above I have found a single script that can be run locally that your chosen CI tool runs is the best solution.&lt;/p&gt;
&lt;p&gt;A dedicated build script has a number of benefits when compared to hosting this logic within your CI tool. Your chosen CI tool can then simply run this build script.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A single, simple script can run run anywhere. Locally or hosted.&lt;/li&gt;
&lt;li&gt;Avoid the use of Domain Specific Languages (DSL's) and rely on native scripts such as Bash or Powershell.&lt;/li&gt;
&lt;li&gt;Simple, native commands are able to be copy/pasted to run. This makes development nice and easy. DSL's prevent this benefit.&lt;/li&gt;
&lt;li&gt;Native commands can be run which makes testing locally possible.&lt;/li&gt;
&lt;li&gt;Avoid the use of base templates or sharing between projects. Standalone build scripts per project are preferred to reduce coupling and dependencies. &lt;/li&gt;
&lt;li&gt;A project specific script is better than a generic template that tries to fit all scenarios.&lt;/li&gt;
&lt;li&gt;A native build script can be committed with the project, any changes will be tracked within source control.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The acid test for this script is that it should be possible to run this anywhere. For example, running this against your personal Azure subscription should setup and run your application as if it was run against the real subscription. Your chosen CI tool can still provide benefits such as a nice UI, test formatting and triggers. It simply executes the script on your behalf. &lt;/p&gt;
&lt;p&gt;If additional features of your CI tool are to be used, these should be complimentary rather than required. Ideally these are setup once in a base template that can be shared between projects of a similar type. If these additional steps do not execute it should not effect the output of the build.&lt;/p&gt;
&lt;h3&gt;Refactoring&lt;/h3&gt;
&lt;p&gt;A previous pipeline had a setup similar to the following, all configured in Team City. In other words, other than building and running tests locally within Visual Studio all the remaining build steps were only run on commit. The steps I took to refactor this are detailed.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Build&lt;/li&gt;
&lt;li&gt;Run Tests&lt;/li&gt;
&lt;li&gt;Package Integration Tests&lt;/li&gt;
&lt;li&gt;Package Acceptance Tests&lt;/li&gt;
&lt;li&gt;Package Application&lt;/li&gt;
&lt;li&gt;Publish Application&lt;/li&gt;
&lt;li&gt;Publish Test Packages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first step in this refactor is to add step zero that will run the build script before anything else.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Run Build&lt;/li&gt;
&lt;li&gt;Build&lt;/li&gt;
&lt;li&gt;Run Tests&lt;/li&gt;
&lt;li&gt;Package Integration Tests&lt;/li&gt;
&lt;li&gt;Package Acceptance Tests&lt;/li&gt;
&lt;li&gt;Package Application&lt;/li&gt;
&lt;li&gt;Publish Application&lt;/li&gt;
&lt;li&gt;Publish Test Packages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Step zero initially will do nothing. Just execute the build script and return. If you can complete this step you are in a good place to start.&lt;/p&gt;
&lt;p&gt;The next step will be to move step 1 into the build script. There are a number of ways to do this and validate the porting. You can check the Team City steps and use the same underlying command and parameters. To validate you can compare the output from the build script against the build output from Team City. In verbose mode the server will log the commands and parameters to stdout. &lt;/p&gt;
&lt;p&gt;After successfully porting step 1 disable this step in Team City. This acts as your backup, if you wish to revert you can do so easily by just enabling the step.&lt;/p&gt;
&lt;p&gt;The next part of this refactor is to actually test your builds. I suggest at least one deploy goes through and is deployed successfully for each step that is ported. While this is slower, it proves the porting is successful and will highlight any issues within a small scope. Slow and steady wins here.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Run Build&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;em&gt;Build&lt;/em&gt;&lt;/del&gt; (Disabled)&lt;/li&gt;
&lt;li&gt;Run Tests&lt;/li&gt;
&lt;li&gt;Package Integration Tests&lt;/li&gt;
&lt;li&gt;Package Acceptance Tests&lt;/li&gt;
&lt;li&gt;Package Application&lt;/li&gt;
&lt;li&gt;Publish Application&lt;/li&gt;
&lt;li&gt;Publish Test Packages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Rinse repeat this process for each of the other steps. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Port&lt;/li&gt;
&lt;li&gt;Disable&lt;/li&gt;
&lt;li&gt;Deploy&lt;/li&gt;
&lt;li&gt;Go to next step&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once all steps that you wish to port are disabled I suggest leaving a small period for the script to bed in. Once you're happy then the disabled steps can be deleted. &lt;/p&gt;
&lt;p&gt;The ideal scenario here is that as much as the build is ported into the dedicated build script, with the only remaining steps either specific to your CI tool or base template specific. The true acid test here is that the script can be run &lt;em&gt;anywhere&lt;/em&gt; as detailed previously.&lt;/p&gt;</content><category term="software-development"></category></entry><entry><title>The Boy Scout Rule is Misunderstood</title><link href="https://blog.shaunfinglas.co.uk/2019/12/the-boy-scout-rule-is-misunderstood.html" rel="alternate"></link><published>2019-12-07T00:00:00+01:00</published><updated>2019-12-07T00:00:00+01:00</updated><author><name>Shaun Finglas</name></author><id>tag:blog.shaunfinglas.co.uk,2019-12-07:/2019/12/the-boy-scout-rule-is-misunderstood.html</id><summary type="html">&lt;h3&gt;What is it?&lt;/h3&gt;
&lt;p&gt;During my time in the Scouts we would clear down our camp site in the same way each time. We would gather everyone in a big circle around the campfire and face outwards. The fire was the center of the camp. &lt;/p&gt;
&lt;p&gt;We would then all walk outwards …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;What is it?&lt;/h3&gt;
&lt;p&gt;During my time in the Scouts we would clear down our camp site in the same way each time. We would gather everyone in a big circle around the campfire and face outwards. The fire was the center of the camp. &lt;/p&gt;
&lt;p&gt;We would then all walk outwards away from the fire up until the edge of the campsite. This boundary would be our personal site, not the full campsite we happened to be stopping in. Along the way if we noticed anything that wasn't right we would fix it there and then. This could involve picking up litter, closing gates, moving items out of the way and anything else. The idea was to put the area back to the way we found it. Then the next group to use the site would have the same experience as we did. Additionally this taught the younger scouts to look after their environment no matter where they are.&lt;/p&gt;
&lt;h3&gt;What is it in Software Development?&lt;/h3&gt;
&lt;p&gt;My personal experience of the "Boy Scout Rule" in software development came from the book Clean Code. This states that just like in the scouts we should aim to leave the codebase we are working with, in a better or equivalent state when we finish. &lt;/p&gt;
&lt;h3&gt;Misuse&lt;/h3&gt;
&lt;p&gt;The misuse of this rule in software development is pretty rampant from my personal experience. Often this "rule" will be used to justify big sweeping changes. Alternatively I've seen changes occur under this "rule" in areas unrelated to the code being worked upon. This would be the real world equivalent of the Scouts leaving the boundary of the campsite or tackling tasks such as felling trees.&lt;/p&gt;
&lt;p&gt;The misuse here is that the software development team is focused on one area, yet changes occur elsewhere meaning bugs or issues may be introduced. Such changes make reverts or rollbacks difficult. Not to mention adding to the noise that changes create such as peer reviews, discussions and testing.&lt;/p&gt;
&lt;p&gt;The definition of &lt;em&gt;better&lt;/em&gt; is also tricky. Refactoring can be highly subjective so when do you stop? In theory no code base is every complete, there will always be something someone would change if given the time.&lt;/p&gt;
&lt;h3&gt;Intent in Software Development&lt;/h3&gt;
&lt;p&gt;The intent of the "Boy Scout Rule" is good, however it is no rule. Don't get pressured into changes for the sake of change. All changes should be local to area you are already working in. &lt;/p&gt;
&lt;p&gt;For example if you change a method of a type, then the method itself, the type and references of the method are fair game for refactoring or other improvements. The opposite of this would be making a change on the other side of the code base just because we can. The reason for this is every change introduces risk and has an associated cost. &lt;/p&gt;
&lt;p&gt;In other words if you are already in the area of the code, refactor as needed. Leave that part of the codebase in a better state. Overtime these small changes will add up. Such hot spots in the codebase for change will become better in terms of quality. Any area that isn't subject to change probably isn't worth worrying about even if it is has glaring issues. &lt;/p&gt;
&lt;p&gt;Increasingly as I gain more experience with software development I find the less code and the less changes made the better. I'm not claiming less lines of code is better - just small, isolated, well focus changes are. Likewise to apply a larger scale change just make lots of small changes in quick succession. These small changes should flow from local development to production.&lt;/p&gt;
&lt;p&gt;The counter point to my case is how do we handle larger changes or architectural changes? In this case the "Boy Scout Rule" is inappropriate. Such changes should be planned, have a value associated with them and estimated. Only then should they be completed if really needed. Often what developers wish to produce is not in sync with the business actual wants or needs.&lt;/p&gt;</content><category term="software-development"></category></entry></feed>